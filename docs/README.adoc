= Konnekt Session – Design Documentation
:icons: font
:source-highlighter: rouge
:toc: left
:toclevels: 3
:sectnums:
:xrefstyle: full

== DDD Modeling Process

This project follows the **Domain-Driven Design Starter Modelling Process**. The architecture documentation is organized into steps:

1. **xref:01-understand.adoc[Understand]** – Business model & strategic goals
2. **xref:02-discover.adoc[Discover]** – Domain discovery (EventStorming)
3. **Decompose** – Subdomain boundaries _(coming soon)_
4. **xref:04-strategize.adoc[Strategize]** – Core Domain Charts
5. **Connect** – Domain message flows _(coming soon)_
6. **Organize** – Team topology _(coming soon)_
7. **Define** – Bounded context details _(coming soon)_
8. **Code** – Implementation patterns _(coming soon)_

Start with **Step 1: Understand** to see the business context, then **Step 4: Strategize** to see our core domain investment strategy.

== 1. Overview

Konnekt Session is a **Rust-based, decentralized multiplayer-lobby library**.
Its purpose is to let developers build multiplayer games that:

* run **entirely in the browser** (Yew + WebAssembly),
* use **Matchbox** only for WebRTC signalling, and
* keep **all game state on the clients** – there is no central game server.

The design uses a **Host/Guest model** with **Spectator Mode** for flexible participation, is expressed through **Domain-Driven Design (DDD)** bounded contexts, and uses a **C4 container architecture**.

== 2. Vision & Scope

* **Vision** – Enable low-latency, peer-to-peer multiplayer experiences without the operational cost of a dedicated backend.
* **In-Scope** – Lobby creation with host/guest roles, activity management, spectator mode, host delegation.
* **Out-Of-Scope** – Persistent server-side storage of game data, matchmaking beyond signalling, or any cloud-hosted "game-engine" component.

== 3. Architectural Constraints

* **No central game server** – Matchbox (`match.konnektoren.help`) handles only WebRTC signalling.
* **Client-side state** – Full lobby state lives in the browser; synchronization is P2P.
* **Host as organizer** – Host manages lobby; can delegate role to guests.
* **Flexible participation** – Guests can toggle between Active and Spectating modes.
* **Rust everywhere** – Frontend (Yew/WASM) written in Rust.

== 4. System Context (C4 - Level 1)

[plantuml, "system-context", png]
----
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml

LAYOUT_WITH_LEGEND()

title Konnekt Session – System Context

Person(user, "User", "Host or Guest")
System(konnekt, "Konnekt Session", "Decentralized multiplayer lobby library")
System_Ext(matchbox, "Matchbox Signalling Server", "WebRTC signalling (match.konnektoren.help)")
System_Ext(browser, "Web Browser", "Chrome, Firefox, Safari")

Rel(user, browser, "Uses")
Rel(browser, konnekt, "Loads Yew SPA")
Rel(konnekt, matchbox, "WebRTC handshake only", "WebSocket")
Rel_Back(matchbox, konnekt, "Relays signalling messages")

@enduml
----

**Narrative**
The **user** (host or guest) interacts with a **Yew SPA** running in their browser. The SPA connects to **Matchbox** for WebRTC signalling, establishing peer-to-peer data channels with other participants. Matchbox never sees game state – it only facilitates the initial connection handshake.

[... Container, Component, Deployment diagrams remain the same ...]

== 10. Domain Model (DDD Perspective)

=== Bounded Contexts

[cols="1,3", options="header"]
|===
|Context
|Responsibility

|**Session Management**
|Core domain – manages `Lobby`, `Participant`, `Activity` aggregates with Host/Guest roles.

|**P2P Networking**
|Handles WebRTC connections, message broadcasting, signature verification.

|**Authentication**
|Manages private keys, identity proofs.

|**Signalling** (External)
|Matchbox server – only WebRTC handshake, no game state.
|===

=== Core Entities & Aggregates

[plantuml, "domain-model", png]
----
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

title Domain Model – Core Entities (Host/Guest Model)

Component(lobby, "Lobby", "Aggregate Root", "id: UUID\nparticipants: Vec<Participant>\nactivities: Vec<Activity>")
Component(participant, "Participant", "Entity", "id: UUID\nlobby_role: LobbyRole\nparticipation_mode: ParticipationMode")
Component(activity, "Activity", "Entity", "id: UUID\nstatus: ActivityStatus\ndata: T")
Component(result, "ActivityResult", "Value Object", "activity_id: UUID\nparticipant_id: UUID\nscore: u32")

Component(lobby_role, "LobbyRole", "Enum", "Host | Guest")
Component(participation_mode, "ParticipationMode", "Enum", "Active | Spectating")
Component(status, "ActivityStatus", "Enum", "NotStarted | InProgress | Done")

Rel(lobby, participant, "contains")
Rel(lobby, activity, "contains")
Rel(activity, result, "produces")
Rel(participant, lobby_role, "has")
Rel(participant, participation_mode, "has")
Rel(activity, status, "has")

@enduml
----

=== Key Domain Services

* **LobbyCommandHandler** – Processes commands (`JoinLobby`, `StartActivity`, `KickGuest`, `DelegateHost`).
* **P2P Sync Service** – Broadcasts state updates to all peers via Matchbox data channels.
* **Auth Service** – Signs outgoing messages, verifies incoming signatures, manages keys.

== 11. Glossary

[cols="1,3", options="header"]
|===
|Term
|Definition

|Lobby
|Aggregate root representing a single game session with one host and multiple guests.

|Host
|The lobby organizer with management privileges (can kick guests, start activities, delegate role).

|Guest
|A regular participant in the lobby.

|Active Mode
|Participation mode where guest can submit activity results.

|Spectating Mode
|Participation mode where guest can only watch (cannot submit results).

|Participation Mode
|Whether a guest is actively playing (Active) or watching (Spectating).

|Host Delegation
|Transfer of host role from current host to a guest.

|Activity
|A concrete game/task that active participants can join.

|Matchbox
|External WebRTC signalling server (match.konnektoren.help).

|P2PMessage
|Signed message envelope containing lobby updates.

|LobbyRole
|Whether participant is Host or Guest.
|===

== 12. Architectural Decisions

[cols="2,3", options="header"]
|===
|Decision
|Rationale

|No game server
|Reduces infrastructure costs, improves scalability, enables offline play.

|Host/Guest model
|Intuitive natural language ("host invites guests"). Clear authority hierarchy.

|Spectator mode
|Flexible participation - guests can watch before playing, or take breaks without leaving.

|Single host (v1.0)
|Simplicity. Host can delegate but not share role. Avoids permission conflicts.

|Cryptographic authentication
|Enables persistent identity, prevents impersonation.

|Matchbox for signalling only
|Delegates WebRTC complexity to proven library, keeps codebase focused.

|Client-side state
|Enables instant UI updates, reduces server load, supports offline mode.

|Separation: LobbyRole vs ParticipationMode
|Host/Guest is about authority, Active/Spectating is about participation. Independent concerns.
|===

== 13. Quality Attributes

[cols="1,3", options="header"]
|===
|Attribute
|How it is addressed

|Scalability
|P2P architecture scales with number of guests; signalling server is stateless.

|Reliability
|Host delegation ensures lobby survives disconnections; oldest guest auto-promoted.

|Security
|All messages signed with Ed25519; verification mandatory before state changes.

|Performance
|WebRTC data channels provide low-latency P2P communication.

|Testability
|Pure domain logic, dependency injection, simulated P2P network for tests.

|Flexibility
|Spectator mode allows guests to watch/play dynamically without leaving lobby.
|===

== 14. Risks & Technical Debt

* **Network partitions** – If peers can't reach each other via WebRTC, state may diverge. Mitigation: Implement reconnection logic with state reconciliation.
* **Host key loss** – If host loses their key, they can't reclaim the role. Mitigation: Provide key export/backup UI.
* **Malicious peers** – A peer could spam invalid messages. Mitigation: Rate limiting, signature verification, host kick functionality.
* **Browser compatibility** – WebRTC support varies. Mitigation: Test on major browsers, provide fallback messaging.
* **Spectator gaming** – Guest toggles to Spectating to avoid hard questions. Mitigation: Forbid mode changes during active activity.

== 15. Next Steps

1. Implement **host delegation protocol** in `src/domain/lobby.rs`.
2. Add **participation mode transitions** in `src/domain/participant.rs`.
3. Create **integration tests** for P2P sync scenarios.
4. Build **spectator mode UI** in Yew components.
5. Document **message format** and versioning strategy.
6. Add **observability** – logging, metrics, error tracking.

== 16. References

* **Matchbox** – https://github.com/johanhelsing/matchbox
* **Yew** – https://yew.rs/docs/getting-started/introduction
* **C4 Model** – https://c4model.com/
* **ARC42** – https://arc42.org/
* **DDD** – _Domain-Driven Design_ by Eric Evans
