= ADR-0005: Use Tracing for Logging and Diagnostics

**Status**: Accepted +
**Date**: 2025-12-29 +
**Deciders**: Core Team

== Context

Konnekt Session requires **comprehensive logging and diagnostics** to:

* **Debug P2P connectivity issues** - track WebRTC connection states, ICE candidates, signaling
* **Trace message flow** - follow lobby state updates through the system
* **Monitor performance** - identify bottlenecks in WASM execution
* **Diagnose state divergence** - understand why peers have different lobby states
* **Audit security events** - log signature verification failures, kicked participants
* **Support production troubleshooting** - enable users to export logs for bug reports

=== Key Requirements

* **WASM-compatible** - must work in browser environment
* **Structured logging** - capture context (peer_id, lobby_id, activity_id)
* **Async-aware** - trace requests across async boundaries
* **Minimal overhead** - no performance impact in hot paths
* **Flexible output** - console for dev, exportable for production
* **Spans for tracing** - track operations from start to finish (e.g., "join lobby")

=== Challenges in Browser Environment

* **No file system** - can't write to `/var/log`
* **Console API limited** - basic `console.log()` doesn't capture structure
* **Async complexity** - P2P messages arrive from multiple peers concurrently
* **Bundle size matters** - every KB affects load time
* **User privacy** - logs might contain sensitive data (names, lobby IDs)

=== Alternatives Considered

==== `log` crate
```rust
log::info!("Peer connected: {}", peer_id);
log::debug!("Received message: {:?}", msg);
```

* ✅ **Simple API** - easy to learn
* ✅ **Small footprint** - minimal dependencies
* ✅ **Industry standard** - widely used
* ❌ **No structured data** - just formatted strings
* ❌ **No spans** - can't track operation lifecycle
* ❌ **No async context** - loses correlation across awaits
* ❌ **No performance instrumentation** - timing must be manual

==== `env_logger` (with `log`)
```rust
env_logger::init();
log::info!("Application started");
```

* ✅ **Zero configuration** for basic use
* ✅ **Works with `log` crate**
* ❌ **Doesn't work in WASM** - relies on environment variables
* ❌ **No browser console integration**
* ❌ Same limitations as `log` (no structure, no spans)

==== `console_log` (WASM-specific)
```rust
console_log::init_with_level(log::Level::Debug).unwrap();
```

* ✅ **Browser console integration**
* ✅ **Works with `log` crate**
* ✅ **Small and simple**
* ❌ **Still just strings** - no structured data
* ❌ **No spans or async context**
* ❌ Limited filtering capabilities

==== Custom Logging Solution
* ✅ **Full control** over format and output
* ✅ **Optimized for our use case**
* ❌ **Reinventing the wheel** - significant development effort
* ❌ **Maintenance burden**
* ❌ **Missing ecosystem integrations**

==== `slog`
```rust
let log = slog::Logger::root(drain, o!("version" => "1.0"));
info!(log, "Peer connected"; "peer_id" => %peer_id);
```

* ✅ **Structured logging** - first-class key-value pairs
* ✅ **Composable drains** - flexible output
* ✅ **Type-safe**
* ❌ **Verbose API** - must pass logger everywhere
* ❌ **No span support** - can't track operation duration
* ❌ **Not async-aware** - loses context across awaits
* ❌ Larger learning curve

== Decision

We will use **`tracing`** as the primary logging and diagnostics framework, with **`tracing-wasm`** for browser console integration.

=== Core Dependencies

```toml
[dependencies]
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["registry", "fmt"] }

[target.'cfg(target_arch = "wasm32")'.dependencies]
tracing-wasm = "0.2"

[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

=== Initialization

```rust
// In WASM (browser)
#[cfg(target_arch = "wasm32")]
pub fn init_logging() {
    use tracing_subscriber::layer::SubscriberExt;

    let level = if cfg!(debug_assertions) {
        tracing::Level::DEBUG
    } else {
        tracing::Level::INFO
    };

    tracing_subscriber::registry()
        .with(tracing_wasm::WASMLayer::new(
            tracing_wasm::WASMLayerConfig::default()
                .set_max_level(level)
        ))
        .init();
}

// In native (tests, CLI tools)
#[cfg(not(target_arch = "wasm32"))]
pub fn init_logging() {
    tracing_subscriber::fmt()
        .with_env_filter("konnekt_session=debug")
        .init();
}
```

=== Usage Examples

==== Structured Events
```rust
use tracing::{info, warn, error};

info!(
    peer_id = %peer_id,
    lobby_id = %lobby.id,
    "Peer joined lobby"
);

warn!(
    peer_id = %peer_id,
    attempt = retry_count,
    "Connection attempt failed, retrying"
);

error!(
    peer_id = %peer_id,
    reason = "invalid_signature",
    "Message verification failed"
);
```

==== Spans for Operation Tracking
```rust
use tracing::{instrument, info_span};

#[instrument(skip(self), fields(lobby_id = %self.lobby_id))]
async fn join_lobby(&mut self, participant: Participant) -> Result<()> {
    info!("Starting join process");

    // Automatically includes lobby_id in all logs within this function
    self.verify_capacity()?;
    self.add_participant(participant).await?;

    info!("Join completed successfully");
    Ok(())
}

// Or manually:
async fn handle_message(&self, peer_id: PeerId, msg: Message) {
    let span = info_span!("handle_message", %peer_id, msg_type = ?msg.msg_type());
    let _guard = span.enter();

    info!("Processing message");
    // All logs here include peer_id and msg_type
}
```

==== Performance Instrumentation
```rust
use tracing::instrument;

#[instrument]
fn verify_signature(msg: &SignedMessage) -> Result<()> {
    // Automatically logs:
    // - Entry with args
    // - Exit with duration
    // - Error if Result::Err

    msg.public_key.verify(&msg.signature, &msg.payload)?;
    Ok(())
}
```

==== Async Context Propagation
```rust
async fn process_lobby_update(&self, update: LobbyUpdate) {
    let span = info_span!("process_update", lobby_id = %update.lobby_id);

    async {
        self.validate_update(&update).await?;
        self.apply_update(update).await?;
        self.broadcast_to_peers().await?;
        Ok::<_, Error>(())
    }
    .instrument(span)  // Span context maintained across all awaits
    .await
    .unwrap();
}
```

=== Rationale

==== Structured Logging
Unlike simple string formatting, `tracing` captures structured data:

```rust
// log crate (unstructured)
log::info!("Peer {} joined lobby {}", peer_id, lobby_id);
// Console: "Peer abc123 joined lobby xyz789"

// tracing (structured)
info!(peer_id = %peer_id, lobby_id = %lobby_id, "Peer joined");
// Console: "Peer joined peer_id=abc123 lobby_id=xyz789"
// Can filter/query by lobby_id or peer_id
```

==== Span Tracking
Spans track the full lifecycle of operations:

```rust
let span = info_span!("start_activity", activity_id = %id);
let _guard = span.enter();

// All logs automatically tagged with activity_id
info!("Validating participants");
validate_participants()?;

info!("Broadcasting start");
broadcast_start().await?;

// Automatically logs span duration on exit
```

Browser console output:
```
▼ start_activity{activity_id=act_123} 234ms
    Validating participants
    Broadcasting start
```

==== Async Awareness
`tracing` maintains context across async boundaries:

```rust
async fn connect_to_peer(peer_id: PeerId) {
    let span = info_span!("connect", %peer_id);

    async {
        info!("Creating offer");
        let offer = create_offer().await?;  // peer_id still in context

        info!("Sending to signaling");
        send_to_signaling(offer).await?;    // peer_id still in context

        info!("Waiting for answer");
        let answer = wait_for_answer().await?;  // peer_id still in context

        Ok::<_, Error>(())
    }
    .instrument(span)
    .await
}
```

All logs inside the async block include `peer_id`, even after `.await` points.

==== Zero-Cost Abstractions
When compiled with `--release`, unused log levels are completely removed:

```rust
debug!("Expensive computation: {:?}", compute_expensive_thing());
// In release build with level=INFO, this entire line is compiled away
// compute_expensive_thing() is never called
```

==== Browser Integration
`tracing-wasm` maps spans to browser console groups:

```javascript
// Browser console shows:
▼ join_lobby{lobby_id="xyz"}
  │ Starting join process
  │ Verifying capacity
  │ Adding participant
  └ Join completed (142ms)
```

==== Ecosystem Integration
Future integrations become trivial:

* **Metrics** - Add `tracing-metrics` for Prometheus
* **Distributed tracing** - Add `tracing-opentelemetry` for Jaeger/Zipkin
* **Error reporting** - Sentry/Rollbar have tracing integrations
* **Testing** - `tracing-subscriber` test layer captures logs for assertions

== Consequences

=== Positive

* **Rich debugging context** - structured fields filterable in console
* **Span hierarchy** - see operation call trees in browser DevTools
* **Async transparency** - context preserved across awaits
* **Performance visibility** - automatic timing of instrumented functions
* **Zero runtime cost** - disabled logs compiled away completely
* **Future-proof** - easy to add APM/metrics/distributed tracing later
* **Better error reports** - users can export structured logs with bug reports

=== Negative

* **Steeper learning curve** - more complex than `log::info!()`
* **Larger API surface** - spans, subscribers, layers, filters
* **Binary size increase** - ~30KB to WASM bundle (vs ~5KB for `log`)
* **Compile time impact** - procedural macros slow down builds
* **Verbosity** - structured logging requires more typing

=== Neutral

* **Not compatible with `log`** - but can bridge with `tracing-log` if needed
* **Requires discipline** - teams must agree on span naming conventions
* **Console noise** - need to set appropriate log levels for production

=== Implementation Strategy

==== Phase 1: Foundation (Current)
- [x] Add dependencies to `Cargo.toml`
- [x] Create `src/infrastructure/logging.rs` module
- [x] Initialize in `main.rs` / WASM entry point
- [ ] Document logging conventions in `CONTRIBUTING.md`

==== Phase 2: Domain Layer (Week 1)
- [ ] Instrument all command handlers with `#[instrument]`
- [ ] Add spans for aggregate methods (`Lobby::add_participant`)
- [ ] Log all domain events (participant joined, activity started, etc.)

==== Phase 3: Infrastructure Layer (Week 2)
- [ ] Trace P2P message lifecycle (send → receive → verify → handle)
- [ ] Log WebRTC connection state changes
- [ ] Track signaling message flow

==== Phase 4: Production Readiness (Week 3)
- [ ] Add log export functionality (JSON format for bug reports)
- [ ] Implement log level controls in UI
- [ ] Add privacy filter for sensitive data (PII redaction)
- [ ] Create span naming conventions guide

=== Logging Conventions

==== Log Levels

[cols="1,3,2", options="header"]
|===
|Level |Use Case |Example

|`ERROR`
|Unrecoverable errors requiring user attention
|Signature verification failed, connection lost

|`WARN`
|Recoverable issues or degraded functionality
|Retry attempt, peer timeout, fallback mode

|`INFO`
|Significant state changes
|Lobby created, participant joined, activity started

|`DEBUG`
|Detailed diagnostic information
|Message received, state synchronized, validation passed

|`TRACE`
|Very verbose, internal details
|Individual field updates, serialization details
|===

==== Field Naming

* **IDs**: `lobby_id`, `peer_id`, `activity_id`, `participant_id`
* **Counts**: `participant_count`, `retry_attempt`, `message_size`
* **Durations**: Use spans, not manual timing
* **Errors**: `error = %e` for Display, `error = ?e` for Debug

==== Span Names

* **Commands**: `execute_command`, `join_lobby`, `start_activity`
* **Queries**: `get_lobby_state`, `find_participant`
* **Infrastructure**: `send_message`, `verify_signature`, `connect_peer`

=== Privacy Considerations

Sensitive data must be handled carefully:

```rust
// ❌ BAD - logs user's password
debug!(password = password, "Generating keys");

// ✅ GOOD - omit sensitive data
debug!("Generating keys");

// ✅ GOOD - hash if needed for correlation
debug!(password_hash = %hash(password), "Generating keys");
```

Create a privacy filter for production:

```rust
struct PrivacyFilter;

impl<S: Subscriber> Layer<S> for PrivacyFilter {
    fn on_record(&self, _span: &Id, values: &Record<'_>, _ctx: Context<'_, S>) {
        // Redact fields named "password", "private_key", etc.
    }
}
```

=== Testing with Tracing

```rust
#[cfg(test)]
mod tests {
    use tracing_subscriber::layer::SubscriberExt;
    use tracing_subscriber::Layer;

    #[test]
    fn test_lobby_creation() {
        let subscriber = tracing_subscriber::registry()
            .with(tracing_subscriber::fmt::layer().with_test_writer());

        tracing::subscriber::with_default(subscriber, || {
            // Test code here - logs will be captured
            let lobby = Lobby::new();
            assert!(lobby.participants.is_empty());
        });
    }
}
```

=== Migration Path

If `tracing` proves too complex or too large:

1. **Reduce to `log` crate** - replace `#[instrument]` with manual `log::info!()`
2. **Keep structured data** - use `slog` as middle ground
3. **Domain layer unaffected** - logging is infrastructure concern

The domain layer never depends directly on `tracing`, only through traits if needed.

== References

=== Crates

* **tracing** – https://docs.rs/tracing/
* **tracing-subscriber** – https://docs.rs/tracing-subscriber/
* **tracing-wasm** – https://docs.rs/tracing-wasm/
* **tracing-log bridge** – https://docs.rs/tracing-log/

=== Documentation

* **Tracing Book** – https://tokio.rs/tokio/topics/tracing
* **Best Practices** – https://github.com/tokio-rs/tracing/blob/master/tracing/README.md
* **WASM Support** – https://github.com/old-storyai/tracing-wasm

=== Related ADRs

* xref:0001-use-rust-for-implementation.adoc[ADR-0001] – Rust enables zero-cost tracing abstractions
* xref:0002-use-yew-for-frontend.adoc[ADR-0002] – Yew components can be instrumented with spans
* xref:0003-use-matchbox-for-signaling.adoc[ADR-0003] – WebRTC flows need detailed tracing
