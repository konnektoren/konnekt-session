= ADR-0022: Use tokio-console for Async Runtime Debugging

**Status**: Accepted +
**Date**: 2025-12-30 +
**Deciders**: Core Team

== Context

Konnekt Session uses **async Rust** extensively:

* **P2P event loop** polls WebRTC connections
* **Domain event loop** processes commands asynchronously
* **TUI** runs in separate async tasks
* **Dual event loops** (xref:0020-use-dual-event-loop-with-acl.adoc[ADR-0020]) coordinate via channels

Async debugging challenges:

* **Task starvation** - one loop blocking others
* **Channel deadlocks** - queues filling up
* **Performance** - slow polls causing latency
* **Instrumentation gaps** - `println!` debugging is insufficient

=== Current Debugging Experience

**Without tokio-console**:
[source,rust]
----
// âŒ Blind debugging
tokio::spawn(async move {
    loop {
        println!("P2P loop tick");  // Spam
        p2p_loop.poll();            // How long does this take?
        interval.tick().await;      // Is this task starving?
    }
});
----

* âŒ **No visibility** - can't see task states
* âŒ **Manual instrumentation** - add logs everywhere
* âŒ **Post-mortem only** - no live inspection
* âŒ **Performance blind spots** - can't identify bottlenecks

=== Requirements

* **Live inspection** - see running tasks in real-time
* **Task metrics** - CPU time, poll duration, wait times
* **Resource tracking** - channels, mutexes, semaphores
* **Minimal overhead** - negligible production impact when disabled
* **Developer UX** - easy to enable during development

=== Alternatives Considered

==== `tracing` with logs (current)
[source,rust]
----
#[instrument]
async fn poll(&mut self) {
    debug!("Polling P2P loop");
    // ...
}
----

* âœ… **Already using** - xref:0005-use-tracing-for-logging-and-diagnostics.adoc[ADR-0005]
* âœ… **Production-safe** - structured logs
* âŒ **No live view** - must read logs after
* âŒ **No aggregation** - hard to see task overview
* âŒ **No resource tracking** - can't see channel state

==== `async-profiler` / Flamegraphs
[source,bash]
----
cargo flamegraph --bin konnekt-cli
----

* âœ… **Performance profiling** - find CPU hotspots
* âŒ **No async awareness** - treats tasks as threads
* âŒ **Sampling only** - misses short-lived tasks
* âŒ **Post-mortem** - no live debugging

==== Manual instrumentation
[source,rust]
----
static TASK_COUNT: AtomicUsize = AtomicUsize::new(0);

tokio::spawn(async move {
    TASK_COUNT.fetch_add(1, Ordering::Relaxed);
    // ...
    TASK_COUNT.fetch_sub(1, Ordering::Relaxed);
});
----

* âœ… **Full control** - track exactly what you need
* âŒ **Boilerplate** - manual counters everywhere
* âŒ **Error-prone** - forget to decrement
* âŒ **Limited** - can't track tokio internals

== Decision

We will use **tokio-console** for async runtime debugging during development.

=== Implementation

**Step 1: Add dependencies** (feature-gated):
[source,toml]
----
[dependencies]
tokio = { version = "1.42", features = ["macros", "rt-multi-thread"] }

# Feature-gated for debugging
console-subscriber = { version = "0.4", optional = true }

[features]
console = ["console-subscriber", "tokio/tracing"]
----

**Step 2: Initialize subscriber**:
[source,rust]
----
fn init_tracing() {
    #[cfg(feature = "console")]
    if std::env::var("TOKIO_CONSOLE").is_ok() {
        console_subscriber::init();
        eprintln!("ğŸ” tokio-console enabled on :6669");
        return;
    }

    // Default: tracing-subscriber
    tracing_subscriber::fmt::init();
}
----

**Step 3: Enable in Justfile**:
[source,just]
----
# Run with tokio-console enabled
host-console NAME="TestHost":
    @echo "ğŸ” Starting with tokio-console"
    @echo "   Run 'tokio-console' in another terminal"
    TOKIO_CONSOLE=1 RUSTFLAGS="--cfg tokio_unstable" \
        cargo run --features console -- create-host --name "{{ NAME }}"

# Install tokio-console CLI
install-tokio-console:
    cargo install --locked tokio-console
----

**Step 4: Connect with CLI**:
[source,bash]
----
# Terminal 1: Start app
$ just host-console Alice
ğŸ” Starting with tokio-console
   Run 'tokio-console' in another terminal
ğŸ“¡ Console server started on 127.0.0.1:6669

# Terminal 2: Connect console
$ tokio-console
----

=== Rationale

**Built by Tokio Team**:
* First-party tool for `tokio` runtime
* Deep integration with runtime internals
* Designed specifically for async debugging

**Live Metrics**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tasks                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Name        â”‚ State    â”‚ CPU Time â”‚ Polls      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ p2p_loop    â”‚ Running  â”‚ 125ms    â”‚ 1,234      â”‚
â”‚ domain_loop â”‚ Idle     â”‚ 45ms     â”‚ 567        â”‚
â”‚ tui_render  â”‚ Waiting  â”‚ 10ms     â”‚ 89         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Resource Tracking**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Resources (Channels)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Type        â”‚ Capacity â”‚ Messages â”‚ Waiting    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ mpsc        â”‚ 100      â”‚ 23       â”‚ 0          â”‚
â”‚ mpsc        â”‚ 100      â”‚ 98       â”‚ 2 tasks    â”‚ â† Bottleneck!
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Zero Production Cost**:
* Disabled by default (feature flag)
* No runtime overhead when not compiled
* Only in development builds

== Consequences

=== Positive

* âœ… **Live visibility** - see tasks running in real-time
* âœ… **Performance insights** - identify slow polls instantly
* âœ… **Deadlock detection** - spot blocked tasks/channels
* âœ… **Developer productivity** - debug async without guessing
* âœ… **Official tooling** - maintained by Tokio team

=== Negative

* âŒ **Development only** - not for production monitoring
* âŒ **Requires unstable features** - `RUSTFLAGS="--cfg tokio_unstable"`
* âŒ **Extra dependency** - ~500KB in dev builds
* âŒ **Network port** - console server uses TCP :6669

=== Neutral

* **Feature-gated** - opt-in via `--features console`
* **Terminal-based** - not a web UI (see alternatives below)
* **Local only** - doesn't support remote debugging (security)

== Usage Patterns

=== Pattern 1: Task Monitoring
```bash
# Start with console enabled
$ TOKIO_CONSOLE=1 cargo run --features console

# In another terminal
$ tokio-console
# Navigate with arrow keys
# Press 'd' for task details
# Press 'r' for resource view
```

=== Pattern 2: Performance Profiling
[source,rust]
----
// Instrument critical sections
#[instrument(name = "p2p_poll")]
async fn poll_p2p(&mut self) {
    // tokio-console shows:
    // - How long this takes
    // - How often it's called
    // - If it's blocking other tasks
}
----

=== Pattern 3: Deadlock Debugging
```
# Console shows:
# Task A: Waiting on channel RX (10s)
# Task B: Waiting on channel TX (10s)
# â†’ Deadlock detected!
```

== When to Use

**Use tokio-console for**:
* âœ… Task starvation issues
* âœ… Channel backpressure debugging
* âœ… Async performance profiling
* âœ… Understanding task spawn patterns

**Don't use for**:
* âŒ Production monitoring (use metrics/logs)
* âŒ CPU profiling (use `cargo flamegraph`)
* âŒ Memory debugging (use `valgrind`/`heaptrack`)

== Future Enhancements

**Web UI Alternative**:
* Consider `tokio-metrics` + web dashboard for remote debugging
* Example: https://github.com/tokio-rs/console/issues/172

**Metric Export**:
* Export console metrics to Prometheus/Grafana
* https://github.com/tokio-rs/console/issues/89

== References

* **tokio-console** â€“ https://github.com/tokio-rs/console
* **Documentation** â€“ https://docs.rs/console-subscriber/
* **Tutorial** â€“ https://tokio.rs/tokio/topics/tracing

=== Related ADRs

* xref:0020-use-dual-event-loop-with-acl.adoc[ADR-0020] â€“ Dual loops benefit from task monitoring
* xref:0005-use-tracing-for-logging-and-diagnostics.adoc[ADR-0005] â€“ Integrates with tracing
* xref:0011-use-std-async-for-wasm-compatibility.adoc[ADR-0011] â€“ Async runtime foundation
