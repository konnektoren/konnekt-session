= ADR-0023: Use tracing-chrome for Performance Profiling

**Status**: Accepted +
**Date**: 2025-12-30 +
**Deciders**: Core Team

== Context

Konnekt Session requires **performance profiling** to:

* **Measure latency** - P2P message round-trips
* **Identify bottlenecks** - slow event processing
* **Optimize hot paths** - domain command execution
* **Visualize timelines** - see event sequences

Traditional profiling tools don't integrate well with `tracing`:

* **`perf`/`flamegraph`** - sampling-based, misses tracing spans
* **`criterion`** - microbenchmarks, not real workloads
* **Manual timing** - error-prone, scattered code

=== Current Profiling Experience

**Without tracing-chrome**:
[source,rust]
----
// âŒ Manual timing
let start = Instant::now();
p2p_loop.poll();
let duration = start.elapsed();
println!("Poll took: {:?}", duration);  // Lost in logs
----

* âŒ **No visualization** - text output only
* âŒ **No context** - can't see nested spans
* âŒ **Manual instrumentation** - add timing everywhere
* âŒ **No timeline** - can't see parallel execution

=== Requirements

* **Visual timeline** - see spans over time
* **Nested spans** - understand call hierarchies
* **Async-aware** - track task switches
* **Low overhead** - usable in development
* **Standard format** - works with existing tools

=== Alternatives Considered

==== `tracing-subscriber` with JSON logs
[source,rust]
----
tracing_subscriber::fmt()
    .json()
    .init();
----

* âœ… **Structured output** - machine-readable
* âŒ **No visualization** - requires custom tooling
* âŒ **Hard to analyze** - grep/jq not ideal for timelines

==== `tracing-flame` (flamegraphs)
[source,rust]
----
let (flame_layer, _guard) = tracing_flame::FlameLayer::new();
tracing_subscriber::registry().with(flame_layer).init();
----

* âœ… **Call stacks** - good for CPU profiling
* âŒ **No timeline** - aggregates spans
* âŒ **No concurrency view** - can't see parallel tasks
* âŒ **Less familiar** - not standard format

==== Custom tracing layer
[source,rust]
----
struct TimingLayer {
    spans: HashMap<Id, Instant>,
}

impl<S> Layer<S> for TimingLayer { /* ... */ }
----

* âœ… **Full control** - track exactly what you need
* âŒ **Reinventing wheel** - Chrome format already exists
* âŒ **No tooling** - need to build visualizer

== Decision

We will use **tracing-chrome** to export tracing spans to Chrome's trace format (Perfetto).

=== Implementation

**Step 1: Add dependency** (feature-gated):
[source,toml]
----
[dependencies]
tracing-chrome = { version = "0.7", optional = true }

[features]
chrome-trace = ["tracing-chrome"]
----

**Step 2: Initialize layer**:
[source,rust]
----
fn init_tracing() {
    #[cfg(feature = "chrome-trace")]
    {
        let (chrome_layer, _guard) = tracing_chrome::ChromeLayerBuilder::new()
            .file("trace.json")
            .include_args(true)
            .build();

        tracing_subscriber::registry()
            .with(chrome_layer)
            .init();

        eprintln!("ğŸ“Š Chrome trace enabled: trace.json");
        eprintln!("   View at: https://ui.perfetto.dev/");

        // Keep guard alive
        std::mem::forget(_guard);
        return;
    }

    // Default: fmt layer
    tracing_subscriber::fmt::init();
}
----

**Step 3: Instrument code** (using existing `tracing`):
[source,rust]
----
#[instrument(skip(self))]
async fn poll(&mut self) -> usize {
    let processed = self.process_network_events();

    let _span = info_span!("translate_messages").entered();
    self.translate_messages();

    processed
}
----

**Step 4: Enable in Justfile**:
[source,just]
----
# Run with Chrome tracing
host-trace NAME="TestHost":
    @echo "ğŸ“Š Chrome trace enabled"
    cargo run --features chrome-trace -- create-host --name "{{ NAME }}"
    @echo ""
    @echo "âœ… Trace written to: trace.json"
    @echo "   Open: https://ui.perfetto.dev/"
    @echo "   Then drag-and-drop trace.json"
----

**Step 5: View in Perfetto**:
```bash
$ just host-trace Alice
ğŸ“Š Chrome trace enabled
# ... run session ...
âœ… Trace written to: trace.json

# Open browser to https://ui.perfetto.dev/
# Drag trace.json onto page
```

=== Rationale

**Chrome DevTools Format**:
* **Standard** - used by Chrome, Firefox, Edge
* **Perfetto** - advanced UI (https://ui.perfetto.dev/)
* **Widely supported** - many tools can read it

**Visual Timeline**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ p2p_loop::poll           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                    â”‚ 10ms
â”‚   â”œâ”€ poll_events         â–ˆâ–ˆâ–ˆ                         â”‚ 3ms
â”‚   â”œâ”€ translate_messages  â–ˆâ–ˆ                          â”‚ 2ms
â”‚   â””â”€ send_events         â–ˆâ–ˆâ–ˆ                         â”‚ 3ms
â”‚                                                       â”‚
â”‚ domain_loop::poll                 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ              â”‚ 5ms
â”‚   â””â”€ process_commands             â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ              â”‚ 5ms
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         0ms        5ms       10ms      15ms      20ms
```

**Async Task Tracking**:
* See task switches
* Identify blocking operations
* Visualize concurrent execution

**Zero Production Cost**:
* Feature-gated (`--features chrome-trace`)
* No overhead when not enabled
* File-based (no network overhead)

== Consequences

=== Positive

* âœ… **Visual profiling** - see execution timeline
* âœ… **Nested spans** - understand call hierarchies
* âœ… **Async-aware** - track tasks across polls
* âœ… **Standard tooling** - Perfetto is powerful
* âœ… **Low overhead** - ~5-10% performance impact

=== Negative

* âŒ **Large traces** - long sessions = big files
* âŒ **Post-mortem only** - must run to completion
* âŒ **File I/O** - writes to disk during execution
* âŒ **Not for production** - debugging tool only

=== Neutral

* **Feature-gated** - opt-in for profiling sessions
* **Complements other tools** - use with `tokio-console` for full picture
* **Manual upload** - drag-drop to Perfetto (no auto-upload)

== Usage Patterns

=== Pattern 1: Performance Investigation
```bash
# Enable tracing
$ cargo run --features chrome-trace -- create-host --name Alice

# Simulate workload
# (join guests, run activities, etc.)

# Ctrl+C to stop
# Open trace.json in Perfetto
```

**In Perfetto**:
* **Zoom** - scroll wheel
* **Pan** - drag timeline
* **Details** - click on span
* **Search** - find specific events

=== Pattern 2: Latency Analysis
[source,rust]
----
#[instrument(name = "handle_message", fields(msg_size = msg.len()))]
async fn handle_message(&mut self, msg: Vec<u8>) {
    let _parse = info_span!("parse_message").entered();
    let command = parse(msg)?;
    drop(_parse);

    let _execute = info_span!("execute_command").entered();
    self.domain.execute(command)?;
}
----

**In Perfetto**:
```
handle_message (12ms total)
â”œâ”€ parse_message (1ms)    â† Fast
â””â”€ execute_command (11ms) â† Bottleneck!
```

=== Pattern 3: Concurrency Visualization
```
Task 1: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Task 2:       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ           â–ˆâ–ˆâ–ˆâ–ˆ
        â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼
        0ms  5ms  10ms 15ms 20ms 25ms
```

Shows:
* Which tasks run when
* Overlapping execution
* Idle time

== When to Use

**Use tracing-chrome for**:
* âœ… Performance profiling
* âœ… Latency investigations
* âœ… Understanding execution flow
* âœ… Identifying bottlenecks

**Don't use for**:
* âŒ Production monitoring (use metrics)
* âŒ Live debugging (use `tokio-console`)
* âŒ Memory profiling (use `heaptrack`)
* âŒ Long-running sessions (traces get huge)

== Comparison: tokio-console vs tracing-chrome

[cols="1,2,2", options="header"]
|===
|Aspect
|tokio-console
|tracing-chrome

|**Use case**
|Live async debugging
|Performance profiling

|**View**
|Real-time TUI
|Post-mortem timeline

|**Focus**
|Task states, resources
|Span durations, hierarchy

|**When**
|Debugging deadlocks, starvation
|Optimizing performance

|**Output**
|Network stream
|JSON file
|===

**Use both together**:
```bash
# Terminal 1: Run with both enabled
$ TOKIO_CONSOLE=1 cargo run \
    --features "console,chrome-trace" \
    -- create-host --name Alice

# Terminal 2: Live task monitoring
$ tokio-console

# After Ctrl+C: Open trace.json in Perfetto
```

== Perfetto Tips

**Keyboard shortcuts**:
* `W` - Zoom in
* `S` - Zoom out
* `A` - Pan left
* `D` - Pan right
* `/` - Search

**Useful views**:
* **Flame Chart** - aggregated call stacks
* **Counter Tracks** - memory/CPU over time
* **Flow Events** - message passing (if instrumented)

**SQL Analysis**:
```sql
-- Find slowest spans
SELECT name, dur/1e6 as duration_ms
FROM slice
ORDER BY dur DESC
LIMIT 10;
```

== References

* **tracing-chrome** â€“ https://docs.rs/tracing-chrome/
* **Perfetto UI** â€“ https://ui.perfetto.dev/
* **Chrome Trace Format** â€“ https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/

=== Related ADRs

* xref:0022-use-tokio-console-for-async-debugging.adoc[ADR-0022] â€“ Complements tokio-console
* xref:0005-use-tracing-for-logging-and-diagnostics.adoc[ADR-0005] â€“ Uses tracing spans
* xref:0020-use-dual-event-loop-with-acl.adoc[ADR-0020] â€“ Profile dual loops
