= Step 4: Strategize â€“ Core Domain Charts
:icons: font
:toc: left
:toclevels: 3
:sectnums:

== Purpose

Identify which subdomains are **core** (strategic differentiators) vs **supporting** vs **generic**, so we can allocate resources appropriately.

== Core Domain Chart

[plantuml, "core-domain-chart", png]
----
@startuml
!define CORE_COLOR #FF6B6B
!define SUPPORTING_COLOR #4ECDC4
!define GENERIC_COLOR #95E1D3

title Konnekt Session â€“ Core Domain Chart (Revised)

' Axes
!define MAX_COMPLEXITY 100
!define MAX_DIFFERENTIATION 100

rectangle "Business Differentiation â†‘" as y_axis
rectangle "Domain Complexity â†’" as x_axis

' Core Domains (high differentiation, high/medium complexity)
rectangle "Lobby\nManagement" as lobby_mgmt CORE_COLOR
rectangle "Activity\nLifecycle" as activity_lifecycle CORE_COLOR
rectangle "Host/Guest\nManagement" as role_mgmt CORE_COLOR

' Supporting Domains (medium differentiation, medium complexity)
rectangle "Activity\nCatalog &\nPlugins" as activity_catalog SUPPORTING_COLOR
rectangle "Participation\nMode\n(Spectator)" as participation_mode SUPPORTING_COLOR
rectangle "Authentication\n& Identity" as auth SUPPORTING_COLOR
rectangle "Game State\nSerialization" as game_state SUPPORTING_COLOR

' Generic Domains (low differentiation, low/medium complexity)
rectangle "P2P State Sync\n(Round-Robin)" as p2p_sync GENERIC_COLOR
rectangle "WebRTC\nSignalling" as webrtc GENERIC_COLOR
rectangle "Message\nSerialization" as serialization GENERIC_COLOR
rectangle "Local Storage" as storage GENERIC_COLOR

' Positioning
lobby_mgmt -[hidden]-> activity_lifecycle
activity_lifecycle -[hidden]-> role_mgmt
role_mgmt -[hidden]-> activity_catalog
activity_catalog -[hidden]-> participation_mode
participation_mode -[hidden]-> auth
auth -[hidden]-> game_state
game_state -[hidden]-> p2p_sync
p2p_sync -[hidden]-> webrtc
webrtc -[hidden]-> serialization
serialization -[hidden]-> storage

note right of lobby_mgmt
**Core Domain**
This is what users pay for:
â€¢ Creating & managing game sessions
â€¢ Host/Guest model with delegation
â€¢ Managing lobby lifecycle
â€¢ Inviting/kicking guests
High differentiation & complexity
end note

note right of participation_mode
**Supporting Domain**
Enables flexible participation:
â€¢ Active vs Spectating modes
â€¢ Toggle between modes
â€¢ Not highly differentiating
(many systems have "observer mode")
end note

note right of p2p_sync
**Generic Subdomain**
Round-robin consensus is well-known
Use existing patterns (Raft-like, CRDT)
Low differentiation: infrastructure concern
Can use library or standard algorithm
end note

@enduml
----

== Domain Classification (Revised)

[cols="2,1,1,3", options="header"]
|===
|Subdomain
|Type
|Investment Level
|Rationale

|**Lobby Management**
|Core
|â­â­â­â­â­
|â€¢ **Primary business value** â€“ what developers integrate for
â€¢ Managing session lifecycle (create, join, leave, close)
â€¢ Guest admission control (passwords, invites, kicks)
â€¢ Lobby configuration (max guests, privacy settings)
â€¢ This is what makes the product unique & valuable

|**Activity Lifecycle**
|Core
|â­â­â­â­â­
|â€¢ **Core user workflow** â€“ starting/stopping games
â€¢ Activity state machine (planned â†’ in-progress â†’ finished)
â€¢ Results collection from active guests
â€¢ Activity ordering & queue management
â€¢ Critical to user experience

|**Host/Guest Management**
|Core
|â­â­â­â­â­
|â€¢ **Domain-specific logic** â€“ Host/Guest model
â€¢ Host delegation (transferring control)
â€¢ Guest permissions & restrictions
â€¢ Business rules about who can do what
â€¢ Differentiates from generic "player" models

|**Participation Mode (Spectator)**
|Supporting
|â­â­â­
|â€¢ Enables flexibility (important for UX)
â€¢ Active â†” Spectating mode transitions
â€¢ Result submission restrictions
â€¢ Moderate complexity (state + validation)
â€¢ Not highly differentiating (many systems have observers)

|**Activity Catalog & Plugins**
|Supporting
|â­â­â­
|â€¢ Enables extensibility (important for adoption)
â€¢ Activity registration & discovery
â€¢ Plugin versioning & compatibility
â€¢ Moderate complexity (trait system)
â€¢ Not differentiating (many libs have plugins)

|**Authentication & Identity**
|Supporting
|â­â­â­
|â€¢ Essential for security, not differentiating
â€¢ Key generation & storage (Ed25519)
â€¢ Signature verification
â€¢ Identity persistence (LocalStorage)
â€¢ Use standard crypto libraries

|**Game State Serialization**
|Supporting
|â­â­
|â€¢ Necessary for P2P sync
â€¢ Activity-specific data schemas
â€¢ Versioning for backwards compatibility
â€¢ Use serde + custom codecs if needed

|**P2P State Sync (Round-Robin)**
|Generic
|â­â­
|â€¢ **Infrastructure concern**, not business logic
â€¢ Well-known distributed consensus patterns
â€¢ Round-robin leader election is textbook CS
â€¢ Use existing algorithms (Raft-like, CRDT)
â€¢ Low differentiation (commodity)

|**WebRTC Signalling**
|Generic
|â­
|â€¢ Solved problem (Matchbox library)
â€¢ Zero differentiation
â€¢ Use Matchbox as-is

|**Message Serialization**
|Generic
|â­
|â€¢ Solved problem (serde, bincode)
â€¢ No differentiation

|**Local Storage**
|Generic
|â­
|â€¢ Browser API wrapper
â€¢ Trivial complexity
|===

== Revised Architecture: Separation of Concerns

=== Layered Architecture

[source]
----
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Core Domain: Lobby Management                    â”‚
â”‚  (Business Logic: Host/Guest, Activities, Permissions)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“ uses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Supporting: Participation Mode                      â”‚
â”‚        (Active/Spectating, Mode Transitions)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“ uses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Supporting: Authentication & Identity               â”‚
â”‚        (Keys, Signatures, Identity Proofs)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“ uses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Generic Infrastructure: P2P State Sync Layer          â”‚
â”‚  (Round-Robin Consensus, Message Ordering, Replication) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“ uses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Generic Infrastructure: WebRTC Transport              â”‚
â”‚         (Matchbox, Data Channels, Signalling)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

=== Key Insight

**Host role is domain logic, not sync infrastructure:**

* **Domain Layer**: Host is a `LobbyRole` enum value on a `Participant` entity
  - Business rules: "Only host can start activities"
  - Domain events: `HostDelegated`, `GuestPromotedToHost`
  - Aggregate invariants: "Lobby must have exactly one host"

* **Participation Layer**: Active/Spectating is a separate concern
  - Business rules: "Spectating guests cannot submit results"
  - Domain events: `ParticipationModeChanged`
  - Can change independently of host/guest role

* **Infrastructure Layer**: Round-robin leader election for state sync
  - Technical concern: "Who broadcasts the next state update?"
  - Could be ANY peer (not necessarily the domain host)
  - Could rotate every N seconds or every M messages
  - Completely decoupled from domain concept of "host"

=== Example Scenario

[source]
----
Lobby has 4 participants:
  - Alice (Host, Active mode)
  - Bob (Guest, Active mode)
  - Carol (Guest, Active mode)
  - Dave (Guest, Spectating mode)

P2P Sync uses round-robin:
  - Cycle 1: Alice broadcasts
  - Cycle 2: Bob broadcasts
  - Cycle 3: Carol broadcasts
  - Cycle 4: Dave broadcasts
  - Cycle 5: Alice broadcasts again
  (All peers participate in sync, regardless of participation mode)

Alice (domain host) can:
  - Kick guests (domain logic)
  - Start activities (domain logic)
  - Toggle her own participation mode (Active â†” Spectating)

Bob/Carol (guests, active) can:
  - Submit activity results (allowed when Active)
  - Toggle to Spectating mode (self-controlled)
  - Their P2P broadcasts replicate Alice's commands

Dave (guest, spectating) can:
  - Watch activities (read-only)
  - Toggle to Active mode (to participate)
  - Still participates in P2P sync broadcasts

All guests cannot:
  - Execute host commands (domain forbids it)
  - Kick other guests
  - Start/stop activities
----

== Complexity Assessment (Revised)

[cols="2,1,4", options="header"]
|===
|Subdomain
|Complexity Score (1-10)
|Complexity Drivers

|**Lobby Management**
|8
|â€¢ Complex state machine (lobby states)
|â€¢ Multi-actor concurrency (simultaneous joins)
|â€¢ Invariant enforcement (max guests, unique names)
|â€¢ Password protection & invite codes
|â€¢ Lobby closure & cleanup logic
|â€¢ Edge cases: host leaves, last guest leaves

|**Activity Lifecycle**
|7
|â€¢ Activity state transitions (planned â†’ running â†’ done)
|â€¢ Result collection from active guests only
|â€¢ Timeout handling (max activity duration)
|â€¢ Activity cancellation & restart logic
|â€¢ Scoring & leaderboard calculations (excluding spectators)
|â€¢ Edge cases: activity running when host disconnects

|**Host/Guest Management**
|7
|â€¢ Host delegation rules (when, to whom)
|â€¢ Auto-promotion when host leaves
|â€¢ Permission enforcement (who can do what)
|â€¢ Guest kick logic & notifications
|â€¢ Edge cases: all guests leave, host delegates mid-activity

|**Participation Mode (Spectator)**
|5
|â€¢ Mode transition rules (Active â†” Spectating)
|â€¢ When mode changes are allowed (not during activity)
|â€¢ Result submission validation (only Active guests)
|â€¢ Forced mode changes by host (optional)
|â€¢ Activity completion logic (only count Active guests)

|**Activity Catalog & Plugins**
|5
|â€¢ Plugin registration & lifecycle
|â€¢ Versioning & compatibility checks
|â€¢ Activity-specific data schemas
|â€¢ Hot-reload considerations

|**Authentication & Identity**
|4
|â€¢ Key generation (Ed25519)
|â€¢ Signature verification
|â€¢ Key persistence & recovery
|â€¢ Clock skew handling (timestamp verification)

|**Game State Serialization**
|3
|â€¢ Schema evolution (backwards compatibility)
|â€¢ Compression for large states
|â€¢ Partial updates (deltas)

|**P2P State Sync (Round-Robin)**
|4
|â€¢ **Well-studied problem** (use existing algorithms)
|â€¢ Leader election (round-robin with timeouts)
|â€¢ Message ordering (sequence numbers)
|â€¢ Conflict resolution (last-write-wins)
|â€¢ Use Raft, CRDT, or simple round-robin

|**WebRTC Signalling**
|2
|â€¢ Matchbox handles complexity

|**Message Serialization**
|2
|â€¢ Serde derive macros

|**Local Storage**
|1
|â€¢ Browser API wrapper
|===

== Differentiation Assessment (Revised)

[cols="2,1,4", options="header"]
|===
|Subdomain
|Differentiation Score (1-10)
|Differentiation Drivers

|**Lobby Management**
|10
|â€¢ **Primary value proposition** for developers
|â€¢ Unique UX: seamless lobby flows
|â€¢ Superior DX: simple API for complex workflows
|â€¢ Competitive advantage: easier than building from scratch
|â€¢ This is what developers evaluate when choosing the library

|**Activity Lifecycle**
|9
|â€¢ **Core user experience** â€“ starting/stopping games
|â€¢ Unique approach to activity queuing & results
|â€¢ Differentiation in how activities integrate
|â€¢ Better than generic "game session" libraries

|**Host/Guest Management**
|9
|â€¢ **Unique model** (not just "admin" vs "player")
|â€¢ Host delegation without full reconnect
|â€¢ Smooth host transitions
|â€¢ More sophisticated than most lobby libs
|â€¢ Natural language ("host invites guests")

|**Participation Mode (Spectator)**
|4
|â€¢ Nice-to-have feature for UX
|â€¢ Not highly differentiating (many systems have "observer mode")
|â€¢ Smooth toggling is a plus
|â€¢ Not a primary decision factor for developers

|**Activity Catalog & Plugins**
|5
|â€¢ Good plugin system improves DX
|â€¢ Moderate differentiation (ease of adding games)
|â€¢ Table stakes for a game library

|**Authentication & Identity**
|3
|â€¢ Everyone needs auth, not unique
|â€¢ Slight differentiation in UX (key recovery)

|**Game State Serialization**
|2
|â€¢ Standard problem, standard solution

|**P2P State Sync (Round-Robin)**
|2
|â€¢ **Infrastructure, not differentiator**
|â€¢ Users don't care HOW state syncs, just that it works
|â€¢ Round-robin is well-known (not novel)
|â€¢ Could swap for Raft/CRDT without users noticing

|**WebRTC Signalling**
|1
|â€¢ Commodity (Matchbox)

|**Message Serialization**
|1
|â€¢ Completely generic

|**Local Storage**
|1
|â€¢ Browser standard
|===

== Investment Strategy (Revised)

[cols="2,3,3", options="header"]
|===
|Domain Type
|Investment Approach
|Example Actions

|**Core**
(Lobby, Activity Lifecycle, Host/Guest Mgmt)
|â€¢ **Build in-house** with highest quality
|â€¢ Deep domain modeling (DDD tactical patterns)
|â€¢ Extensive testing (domain scenarios)
|â€¢ Rich documentation & examples
|â€¢ Continuous UX improvement
|â€¢ This is where we innovate
|â€¢ Write domain models (aggregates, entities)
|â€¢ EventStorming sessions with users
|â€¢ Property-based testing for invariants
|â€¢ Tutorial videos & interactive docs
|â€¢ Blog posts about host/guest patterns

|**Supporting**
(Participation Mode, Activity Catalog, Auth)
|â€¢ **Build competently** using best practices
|â€¢ Leverage standard patterns
|â€¢ Good test coverage
|â€¢ Clear API documentation
|â€¢ State machine for mode transitions
|â€¢ Use Rust trait system for plugins
|â€¢ Standard crypto libraries (ring, ed25519-dalek)
|â€¢ API reference docs

|**Generic**
(P2P Sync, WebRTC, Storage)
|â€¢ **Buy, use libraries, or use textbook algorithms**
|â€¢ Minimal custom code
|â€¢ Thin wrappers only if needed
|â€¢ Outsource to community/libraries
|â€¢ **Use existing round-robin/Raft/CRDT library**
|â€¢ Use Matchbox for WebRTC
|â€¢ Use web-sys for LocalStorage
|â€¢ Copy standard algorithms from papers/books
|===

== Domain Model: Host/Guest + Spectator Mode

=== Rust Implementation

```rust
// Domain layer: Host/Guest roles
pub enum LobbyRole {
    Host,   // Can manage lobby, kick guests, start activities
    Guest,  // Regular participant
}

// Participation layer: Active vs Spectating
pub enum ParticipationMode {
    Active,      // Can participate in activities
    Spectating,  // View-only, cannot submit results
}

pub struct Participant {
    id: Uuid,
    name: String,
    lobby_role: LobbyRole,
    participation_mode: ParticipationMode,
}

impl Participant {
    pub fn is_host(&self) -> bool {
        matches!(self.lobby_role, LobbyRole::Host)
    }

    pub fn can_submit_results(&self) -> bool {
        matches!(self.participation_mode, ParticipationMode::Active)
    }

    pub fn can_manage_lobby(&self) -> bool {
        self.is_host()
    }

    pub fn toggle_spectator_mode(&mut self) -> Result<(), DomainError> {
        self.participation_mode = match self.participation_mode {
            ParticipationMode::Active => ParticipationMode::Spectating,
            ParticipationMode::Spectating => ParticipationMode::Active,
        };
        Ok(())
    }
}

// Infrastructure layer: Sync leader (independent)
pub struct SyncLeader {
    current_broadcaster: PeerId,
    rotation_schedule: Vec<PeerId>,
}

// These are INDEPENDENT:
// - Domain host (LobbyRole::Host) manages lobby
// - Participation mode (Active/Spectating) controls activity submission
// - Sync leader (infrastructure) controls state broadcast rotation
```

=== Business Rules

```rust
impl Lobby {
    pub fn submit_result(&mut self, participant_id: Uuid, result: ActivityResult)
        -> Result<(), DomainError> {

        let participant = self.find_participant(participant_id)?;

        // Check participation mode
        if !participant.can_submit_results() {
            return Err(DomainError::SpectatorCannotSubmit);
        }

        // Check activity state
        let activity = self.current_activity()?;
        if activity.status != ActivityStatus::InProgress {
            return Err(DomainError::ActivityNotRunning);
        }

        // Submit result
        activity.add_result(participant_id, result)?;

        // Check if all ACTIVE participants have submitted
        if self.all_active_participants_submitted() {
            activity.complete()?;
        }

        Ok(())
    }

    fn all_active_participants_submitted(&self) -> bool {
        let active_participants = self.participants.iter()
            .filter(|p| matches!(p.participation_mode, ParticipationMode::Active))
            .count();

        let submitted_count = self.current_activity()
            .map(|a| a.results.len())
            .unwrap_or(0);

        active_participants == submitted_count
    }
}
```

=== Benefits of Separation

1. **Clear domain model** â€“ Host/Guest is about authority, Active/Spectating is about participation
2. **Flexible UX** â€“ Host can spectate, guests can toggle modes
3. **Testable in isolation** â€“ Test lobby rules without P2P, test participation without host logic
4. **Swappable sync layer** â€“ Can upgrade sync without touching domain code
5. **Natural language** â€“ "Host invites guests" is intuitive

== Alternative Sync Approaches (Future)

Since sync is **generic**, we have options:

[cols="2,3,3,2", options="header"]
|===
|Approach
|Pros
|Cons
|When to Use

|**Round-Robin**
|â€¢ Simple to implement
|â€¢ Fair distribution of broadcast load
|â€¢ Predictable
|â€¢ Single point of failure (current leader)
|â€¢ Latency (wait for your turn)
|v1.0 (simple)

|**Host-Only Broadcast**
|â€¢ Clear authority (domain host = sync leader)
|â€¢ Lowest latency (no rotation)
|â€¢ Host is bottleneck
|â€¢ Host disconnect breaks sync
|v1.0 alternative

|**CRDT (Conflict-Free)**
|â€¢ No leader needed
|â€¢ High availability
|â€¢ Complexity
|â€¢ Larger message sizes
|v2.0 (research)

|**Raft Consensus**
|â€¢ Battle-tested
|â€¢ Leader election built-in
|â€¢ Heavyweight for browser
|â€¢ Overkill for game lobbies
|Future (if needed)
|===

== Risk Analysis (Revised)

[cols="2,3,2,2", options="header"]
|===
|Subdomain
|Risk
|Mitigation
|Priority

|**Lobby Management**
|Complex state machine bugs (edge cases)
|Property-based testing, formal state machine modeling
|ðŸ”´ Critical

|**Activity Lifecycle**
|Race conditions (simultaneous activity starts)
|Domain invariants, command validation
|ðŸ”´ Critical

|**Host/Guest Management**
|Orphaned lobby (host leaves, no guests)
|Auto-close lobby after timeout
|ðŸŸ¡ Medium

|**Participation Mode**
|Mode change during activity (gaming the system)
|Forbid mode changes during active activity
|ðŸŸ¡ Medium

|**P2P Sync**
|Sync leader disconnect
|Timeout + re-election (standard algorithm)
|ðŸŸ¡ Medium

|**Authentication**
|Key loss (user can't rejoin as original identity)
|Key export/backup UX
|ðŸŸ¡ Medium
|===

== Next Steps

1. **Focus 80% effort on Core Domains**:
   - Deep domain modeling for Lobby Management
   - Host delegation state machine design
   - Activity lifecycle with spectator handling
   - Guest permissions & restrictions

2. **Use off-the-shelf for Generic**:
   - Research existing Rust CRDT/Raft libraries
   - Implement simple round-robin as v1.0 sync
   - Document sync layer as swappable component

3. **Validate with users**:
   - EventStorm host/guest workflows
   - Prototype spectator mode UX
   - Test host delegation scenarios
   - Collect feedback on terminology

4. Move to **Step 3: Decompose** to identify subdomain boundaries
