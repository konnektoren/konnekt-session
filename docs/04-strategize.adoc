= Step 4: Strategize â€“ Core Domain Charts
:icons: font
:toc: left
:toclevels: 3
:sectnums:

== Purpose

Identify which subdomains are **core** (strategic differentiators) vs **supporting** vs **generic**, so we can allocate resources appropriately.

== Core Domain Chart

[plantuml, "core-domain-chart", png]
----
@startuml
!define CORE_COLOR #FF6B6B
!define SUPPORTING_COLOR #4ECDC4
!define GENERIC_COLOR #95E1D3

title Konnekt Session â€“ Core Domain Chart (Revised)

' Axes
!define MAX_COMPLEXITY 100
!define MAX_DIFFERENTIATION 100

rectangle "Business Differentiation â†‘" as y_axis
rectangle "Domain Complexity â†’" as x_axis

' Core Domains (high differentiation, high/medium complexity)
rectangle "Lobby\nManagement" as lobby_mgmt CORE_COLOR
rectangle "Activity\nLifecycle" as activity_lifecycle CORE_COLOR
rectangle "Player Role\nManagement" as role_mgmt CORE_COLOR

' Supporting Domains (medium differentiation, medium complexity)
rectangle "Activity\nCatalog &\nPlugins" as activity_catalog SUPPORTING_COLOR
rectangle "Authentication\n& Identity" as auth SUPPORTING_COLOR
rectangle "Game State\nSerialization" as game_state SUPPORTING_COLOR

' Generic Domains (low differentiation, low/medium complexity)
rectangle "P2P State Sync\n(Round-Robin)" as p2p_sync GENERIC_COLOR
rectangle "WebRTC\nSignalling" as webrtc GENERIC_COLOR
rectangle "Message\nSerialization" as serialization GENERIC_COLOR
rectangle "Local Storage" as storage GENERIC_COLOR

' Positioning
lobby_mgmt -[hidden]-> activity_lifecycle
activity_lifecycle -[hidden]-> role_mgmt
role_mgmt -[hidden]-> activity_catalog
activity_catalog -[hidden]-> auth
auth -[hidden]-> game_state
game_state -[hidden]-> p2p_sync
p2p_sync -[hidden]-> webrtc
webrtc -[hidden]-> serialization
serialization -[hidden]-> storage

note right of lobby_mgmt
**Core Domain**
This is what users pay for:
â€¢ Creating & managing game sessions
â€¢ Inviting/kicking players
â€¢ Starting/stopping activities
â€¢ Managing lobby lifecycle
High differentiation & complexity
end note

note right of p2p_sync
**Generic Subdomain**
Round-robin consensus is well-known
Use existing patterns (Raft-like, CRDT)
Low differentiation: infrastructure concern
Can use library or standard algorithm
end note

@enduml
----

== Domain Classification (Revised)

[cols="2,1,1,3", options="header"]
|===
|Subdomain
|Type
|Investment Level
|Rationale

|**Lobby Management**
|Core
|â­â­â­â­â­
|â€¢ **Primary business value** â€“ what developers integrate for
â€¢ Managing session lifecycle (create, join, leave, close)
â€¢ Player admission control (passwords, invites, kicks)
â€¢ Lobby configuration (max players, privacy settings)
â€¢ This is what makes the product unique & valuable

|**Activity Lifecycle**
|Core
|â­â­â­â­â­
|â€¢ **Core user workflow** â€“ starting/stopping games
â€¢ Activity state machine (planned â†’ in-progress â†’ finished)
â€¢ Results collection & aggregation
â€¢ Activity ordering & queue management
â€¢ Critical to user experience

|**Player Role Management**
|Core
|â­â­â­â­
|â€¢ **Domain-specific logic** â€“ Admin/Player/Observer roles
â€¢ Role transitions & permissions
â€¢ Admin delegation (appointing new admin)
â€¢ Observer promotion to player
â€¢ Business rules about who can do what

|**Activity Catalog & Plugins**
|Supporting
|â­â­â­
|â€¢ Enables extensibility (important for adoption)
â€¢ Activity registration & discovery
â€¢ Plugin versioning & compatibility
â€¢ Moderate complexity (trait system)
â€¢ Not differentiating (many libs have plugins)

|**Authentication & Identity**
|Supporting
|â­â­â­
|â€¢ Essential for security, not differentiating
â€¢ Key generation & storage (Ed25519) or Signature verification
â€¢ Identity persistence (LocalStorage)
â€¢ Use standard crypto libraries

|**Game State Serialization**
|Supporting
|â­â­
|â€¢ Necessary for P2P sync
â€¢ Activity-specific data schemas
â€¢ Versioning for backwards compatibility
â€¢ Use serde + custom codecs if needed

|**P2P State Sync (Round-Robin)**
|Generic
|â­â­
|â€¢ **Infrastructure concern**, not business logic
â€¢ Well-known distributed consensus patterns
â€¢ Round-robin leader election is textbook CS
â€¢ Use existing algorithms (Raft-like, CRDT)
â€¢ Low differentiation (commodity)

|**WebRTC Signalling**
|Generic
|â­
|â€¢ Solved problem (Matchbox library)
â€¢ Zero differentiation
â€¢ Use Matchbox as-is

|**Message Serialization**
|Generic
|â­
|â€¢ Solved problem (serde, bincode)
â€¢ No differentiation

|**Local Storage**
|Generic
|â­
|â€¢ Browser API wrapper
â€¢ Trivial complexity
|===

== Revised Architecture: Separation of Concerns

=== Layered Architecture

[source]
----
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Core Domain: Lobby Management                    â”‚
â”‚  (Business Logic: Activities, Roles, Permissions)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“ uses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Supporting: Authentication & Identity               â”‚
â”‚        (Keys, Signatures, Identity Proofs)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“ uses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Generic Infrastructure: P2P State Sync Layer          â”‚
â”‚  (Round-Robin Consensus, Message Ordering, Replication) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“ uses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Generic Infrastructure: WebRTC Transport              â”‚
â”‚         (Matchbox, Data Channels, Signalling)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

=== Key Insight

**Admin role is domain logic, not sync infrastructure:**

* **Domain Layer**: Admin is a `Role` enum value on a `Player` entity
  - Business rules: "Only admin can start activities"
  - Domain events: `AdminChanged`, `PlayerPromotedToAdmin`
  - Aggregate invariants: "Lobby must have exactly one admin"

* **Infrastructure Layer**: Round-robin leader election for state sync
  - Technical concern: "Who broadcasts the next state update?"
  - Could be ANY peer (not necessarily the domain admin)
  - Could rotate every N seconds or every M messages
  - Completely decoupled from domain concept of "admin"

=== Example Scenario

[source]
----
Lobby has 4 players:
  - Alice (Admin role in domain)
  - Bob (Player role)
  - Carol (Player role)
  - Dave (Observer role)

P2P Sync uses round-robin:
  - Cycle 1: Alice broadcasts
  - Cycle 2: Bob broadcasts
  - Cycle 3: Carol broadcasts
  - Cycle 4: Alice broadcasts again
  (Dave doesn't broadcast - not in rotation)

Alice (domain admin) can:
  - Kick players (domain logic)
  - Start activities (domain logic)

Bob/Carol broadcast state but can't:
  - Execute admin commands (domain forbids it)
  - Their broadcasts just replicate Alice's commands
----

== Complexity Assessment (Revised)

[cols="2,1,4", options="header"]
|===
|Subdomain
|Complexity Score (1-10)
|Complexity Drivers

|**Lobby Management**
|8
|â€¢ Complex state machine (lobby states)
|â€¢ Multi-actor concurrency (simultaneous joins)
|â€¢ Invariant enforcement (max players, unique names)
|â€¢ Password protection & invite codes
|â€¢ Lobby closure & cleanup logic
|â€¢ Edge cases: admin leaves, last player leaves

|**Activity Lifecycle**
|7
|â€¢ Activity state transitions (planned â†’ running â†’ done)
|â€¢ Result collection from multiple players
|â€¢ Timeout handling (max activity duration)
|â€¢ Activity cancellation & restart logic
|â€¢ Scoring & leaderboard calculations
|â€¢ Edge cases: activity running when admin disconnects

|**Player Role Management**
|6
|â€¢ Role transition rules (Observer â†” Player, Admin delegation)
|â€¢ Permission enforcement (who can do what)
|â€¢ Admin succession (when admin leaves)
|â€¢ Multi-admin scenarios (co-admins?)
|â€¢ Edge cases: all admins leave simultaneously

|**Activity Catalog & Plugins**
|5
|â€¢ Plugin registration & lifecycle
|â€¢ Versioning & compatibility checks
|â€¢ Activity-specific data schemas
|â€¢ Hot-reload considerations

|**Authentication & Identity**
|4
|â€¢ Key generation (Ed25519)
|â€¢ Signature verification
|â€¢ Key persistence & recovery
|â€¢ Clock skew handling (timestamp verification)

|**Game State Serialization**
|3
|â€¢ Schema evolution (backwards compatibility)
|â€¢ Compression for large states
|â€¢ Partial updates (deltas)

|**P2P State Sync (Round-Robin)**
|4
|â€¢ **Well-studied problem** (use existing algorithms)
|â€¢ Leader election (round-robin with timeouts)
|â€¢ Message ordering (sequence numbers)
|â€¢ Conflict resolution (last-write-wins)
|â€¢ Use Raft, CRDT, or simple round-robin

|**WebRTC Signalling**
|2
|â€¢ Matchbox handles complexity

|**Message Serialization**
|2
|â€¢ Serde derive macros

|**Local Storage**
|1
|â€¢ Browser API wrapper
|===

== Differentiation Assessment (Revised)

[cols="2,1,4", options="header"]
|===
|Subdomain
|Differentiation Score (1-10)
|Differentiation Drivers

|**Lobby Management**
|10
|â€¢ **Primary value proposition** for developers
|â€¢ Unique UX: seamless lobby flows
|â€¢ Superior DX: simple API for complex workflows
|â€¢ Competitive advantage: easier than building from scratch
|â€¢ This is what developers evaluate when choosing the library

|**Activity Lifecycle**
|9
|â€¢ **Core user experience** â€“ starting/stopping games
|â€¢ Unique approach to activity queuing & results
|â€¢ Differentiation in how activities integrate
|â€¢ Better than generic "game session" libraries

|**Player Role Management**
|8
|â€¢ **Flexible role system** (not just "host" vs "player")
|â€¢ Smooth role transitions (Observer â†” Player)
|â€¢ Admin delegation without full reconnect
|â€¢ More sophisticated than most lobby libs

|**Activity Catalog & Plugins**
|5
|â€¢ Good plugin system improves DX
|â€¢ Moderate differentiation (ease of adding games)
|â€¢ Table stakes for a game library

|**Authentication & Identity**
|3
|â€¢ Everyone needs auth, not unique
|â€¢ Slight differentiation in UX (key recovery)

|**Game State Serialization**
|2
|â€¢ Standard problem, standard solution

|**P2P State Sync (Round-Robin)**
|2
|â€¢ **Infrastructure, not differentiator**
|â€¢ Users don't care HOW state syncs, just that it works
|â€¢ Round-robin is well-known (not novel)
|â€¢ Could swap for Raft/CRDT without users noticing

|**WebRTC Signalling**
|1
|â€¢ Commodity (Matchbox)

|**Message Serialization**
|1
|â€¢ Completely generic

|**Local Storage**
|1
|â€¢ Browser standard
|===

== Investment Strategy (Revised)

[cols="2,3,3", options="header"]
|===
|Domain Type
|Investment Approach
|Example Actions

|**Core**
(Lobby, Activity Lifecycle, Role Mgmt)
|â€¢ **Build in-house** with highest quality
|â€¢ Deep domain modeling (DDD tactical patterns)
|â€¢ Extensive testing (domain scenarios)
|â€¢ Rich documentation & examples
|â€¢ Continuous UX improvement
|â€¢ This is where we innovate
|â€¢ Write domain models (aggregates, entities)
|â€¢ EventStorming sessions with users
|â€¢ Property-based testing for invariants
|â€¢ Tutorial videos & interactive docs
|â€¢ Blog posts about domain patterns

|**Supporting**
(Activity Catalog, Auth, Serialization)
|â€¢ **Build competently** using best practices
|â€¢ Leverage standard patterns
|â€¢ Good test coverage
|â€¢ Clear API documentation
|â€¢ Use Rust trait system for plugins
|â€¢ Standard crypto libraries (ring, ed25519-dalek)
|â€¢ Serde for serialization
|â€¢ API reference docs

|**Generic**
(P2P Sync, WebRTC, Storage)
|â€¢ **Buy, use libraries, or use textbook algorithms**
|â€¢ Minimal custom code
|â€¢ Thin wrappers only if needed
|â€¢ Outsource to community/libraries
|â€¢ **Use existing round-robin/Raft/CRDT library**
|â€¢ Use Matchbox for WebRTC
|â€¢ Use web-sys for LocalStorage
|â€¢ Copy standard algorithms from papers/books
|===

== P2P State Sync: Round-Robin Approach

Since P2P state sync is **generic infrastructure**, we can use a simple, well-known algorithm:

=== Round-Robin Leader Election

```rust
// Simple round-robin: each peer gets a turn to broadcast
struct RoundRobinSync {
    peers: Vec<PeerId>,
    current_leader_index: usize,
    rotation_interval: Duration, // e.g., 5 seconds
}

impl RoundRobinSync {
    fn current_leader(&self) -> PeerId {
        self.peers[self.current_leader_index % self.peers.len()]
    }

    fn rotate_leader(&mut self) {
        self.current_leader_index += 1;
    }

    fn am_i_leader(&self, my_id: PeerId) -> bool {
        self.current_leader() == my_id
    }
}
```

=== Decoupling from Domain

```rust
// Domain layer: Admin role is business logic
pub enum Role {
    Admin,    // Can execute admin commands
    Player,   // Can participate in activities
    Observer, // Read-only
}

// Infrastructure layer: Sync leader is technical concern
pub struct SyncLeader {
    current_broadcaster: PeerId, // Who sends next state update
    rotation_schedule: Vec<PeerId>,
}

// These are INDEPENDENT:
// - Domain admin can be different from sync leader
// - Sync leader just replicates commands, doesn't authorize them
// - Domain layer validates "is this user allowed to kick players?"
// - Sync layer just ensures "did this message reach everyone?"
```

=== Benefits of Separation

1. **Simpler domain model** â€“ no mixing of business logic and sync logic
2. **Testable in isolation** â€“ test lobby rules without P2P complexity
3. **Swappable sync layer** â€“ can upgrade from round-robin to Raft without touching domain code
4. **Clear responsibilities** â€“ domain = "what", infrastructure = "how"

== Alternative Sync Approaches (Future)

Since sync is **generic**, we have options:

[cols="2,3,3,2", options="header"]
|===
|Approach
|Pros
|Cons
|When to Use

|**Round-Robin**
|â€¢ Simple to implement
|â€¢ Fair distribution of broadcast load
|â€¢ Predictable
|â€¢ Single point of failure (current leader)
|â€¢ Latency (wait for your turn)
|v1.0 (simple)

|**Admin-Only Broadcast**
|â€¢ Clear authority (domain admin = sync leader)
|â€¢ Lowest latency (no rotation)
|â€¢ Admin is bottleneck
|â€¢ Admin disconnect breaks sync
|v1.0 alternative

|**CRDT (Conflict-Free)**
|â€¢ No leader needed
|â€¢ High availability
|â€¢ Complexity
|â€¢ Larger message sizes
|v2.0 (research)

|**Raft Consensus**
|â€¢ Battle-tested
|â€¢ Leader election built-in
|â€¢ Heavyweight for browser
|â€¢ Overkill for game lobbies
|Future (if needed)
|===

== Risk Analysis (Revised)

[cols="2,3,2,2", options="header"]
|===
|Subdomain
|Risk
|Mitigation
|Priority

|**Lobby Management**
|Complex state machine bugs (edge cases)
|Property-based testing, formal state machine modeling
|ğŸ”´ Critical

|**Activity Lifecycle**
|Race conditions (simultaneous activity starts)
|Domain invariants, command validation
|ğŸ”´ Critical

|**Role Management**
|Orphaned lobby (all admins leave)
|Auto-promote oldest player to admin
|ğŸŸ¡ Medium

|**P2P Sync**
|Sync leader disconnect
|Timeout + re-election (standard algorithm)
|ğŸŸ¡ Medium

|**Authentication**
|Key loss (user can't rejoin as admin)
|Key export/backup UX
|ğŸŸ¡ Medium
|===

== Next Steps

1. **Focus 80% effort on Core Domains**:
   - Deep domain modeling for Lobby Management
   - Activity lifecycle state machine design
   - Role management business rules

2. **Use off-the-shelf for Generic**:
   - Research existing Rust CRDT/Raft libraries
   - Implement simple round-robin as v1.0 sync
   - Document sync layer as swappable component

3. **Validate with users**:
   - EventStorm lobby management flows
   - Prototype activity lifecycle with real games
   - Test role transition UX

4. Move to **Step 2: Discover** to model the core domain collaboratively
